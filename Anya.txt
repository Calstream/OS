 --------------------------------------- 5. Синхронизация потоков ---------------------------------------  
 
• Ключевое слово volatile указывает, что поле может быть изменено несколькими потоками, выполняющимися одновременно. 
Поля, объявленные как volatile , не проходят оптимизацию компилятором, которая предусматривает доступ посредством отдельного потока.

-- Ожидание наступления условия при помощи цикла ---

volatile bool g_vbWait = true;

DWORD WINAPI MyThreadProc(LPVOID pvData)
	{
		// ...
		while (g_vbWait)
		Sleep(0);
		// ...
		return 0;
	}


--- СОБЫТИЯ

События — самая примитивная разновидность объектов ядра. Они содержат счетчик
числа пользователей (как и все объекты ядра) и две булевы переменные: одна сооб
щает тип данного объекта события, другая — его состояние (свободен или занят).
События просто уведомляют об окончании какой либо операции. Объекты собы
тия бывают двух типов: со сбросом вручную (manuallreset events) и с автосбросом
(autooreset events). Первые позволяют возобновлять выполнение сразу нескольких
ждущих потоков, вторые — только одного.

Объекты события обычно используют в том случае, когда какой то поток выпол
няет инициализацию, а затем сигнализирует другому потоку, что тот может продол
жить работу. Инициализирующий поток переводит объект «событие» в занятое состо
яние и приступает к своим операциям. Закончив, он сбрасывает событие в свободное
состояние. Тогда другой поток, который ждал перехода события в свободное состоя
ние, пробуждается и вновь становится планируемым.

-- Creates or opens a named or unnamed event object.

HANDLE WINAPI CreateEvent(
	_In_opt_ LPSECURITY_ATTRIBUTES lpEventAttributes,	// аттрибуты защиты
	_In_ BOOL bManualReset,					// если true, то состояние Event сбрасывается с помощью ResetEvent, 
											 иначе - состояние Event сбрасывается after a single waiting thread has been released. 
	_In_ BOOL bInitialState,				// if this parameter is TRUE, the initial state of the event object is signaled; 
											   otherwise, it is nonsignaled.
	_In_opt_ LPCTSTR lpctszName				// The name of the event object. If lpName is NULL, the event object is created without a name.
);

Параметр bManualReset (булева переменная) сообщает системе, хотите Вы создать
событие со сбросом вручную (TRUE) или с автосбросом (FALSE). Параметр bInitialState
определяет начальное состояние события — свободное (TRUE) или занятое (FALSE).
После того как система создает объекттсобытие,  CreateEvent возвращает описатель
события, специфичный для конкретного процесса. Потоки из других процессов моо
гут получить доступ к этому объекту: 1) вызовом CreateEvent с тем же параметром
lpctszName; 2) наследованием описателя; 3) применением функции DuplicateHandle; и
4) вызовом OpenEvent с передачей в параметре lpctszName имени, совпадающего с укаа
занным в аналогичном параметре функции CreateEvent. 

HANDLE OpenEvent(
DWORD fdwAccess,
BOOL fInherit,
PCTSTR pszName);

Ненужный объект ядра «событие» следует, как всегда, закрыть вызовом CloseHandle.
Создав событие, Вы можете напрямую управлять его состоянием.

-- Sets the specified event object to the signaled state.

BOOL WINAPI SetEvent(
	_In_ HANDLE hEvent
);
	

-- Sets the specified event object to the nonsignaled state.

BOOL WINAPI ResetEvent(
  _In_ HANDLE hEvent
);

Для событий с автосбросом действует следующее правило. Когда его ожидание
потоком успешно завершается, этот объект автоматически сбрасывается в занятое
состояние. Отсюда и произошло название таких объекто всобытий. Для этого объекк
та обычно не требуется вызывать ResetEvent, поскольку система сама восстанавливает
его состояние. А для событий со сбросом вручную никаких побочных эффектов ус
пешного ожидания не предусмотрено.


-- Sets the specified event object to the signaled state and then resets it to the nonsignaled state 
	after releasing the appropriate number of waiting threads.
	
PulseEvent освобождает событие и тут же переводит его обратно в занятое состоо
яние; ее вызов равнозначен последовательному вызову SetEvent и ResetEvent. Если Вы
вызываете PulseEvent для события со сбросом вручную, любые потоки, ждущие этот
объект, становятся планируемыми. При вызове этой функции применительно к соо
бытию с автосбросом пробуждается только один из ждущих потоков. А если ни один
из потоков не ждет объекттсобытие, вызов функции не дает никакого эффекта.
	
	
BOOL WINAPI PulseEvent(
_In_ HANDLE hEvent
);


Условие гонки: (race condition) - особенность функционирования системы,
при которой её выходной сигнал непредсказуемо зависит от
последовательности и/или временных задержек происходящих
в ней событий.

Атомарность: (atomicity) - свойство операции в параллельной системе
по отношению к набору ресурсов, определяющее невозможность
одновременного доступа к ним до завершения операции (+ закрепление или откат).

Критическая секция: (critical section) - участок кода, исполняемый не более
чем одним потоком из числа имеющих доступ к общему
ресурсу синхронизации.

Взаимная блокировка: (mutual exclusion, mutex) - алгоритм обеспечения
неодновременности использования общего ресурса разными
потоками.


--- Критические секции ---

Мьютексы и критические секции одинаковы в том, как они влияют на планирование
ждущих потоков, но различны по некоторым другим характеристикам. Эти объекты
сравниваются на рис. 6.

Критическая секция (critical section) — это небольшой участок кода, требующий монопольного
 доступа к какиммто общим данным. Она позволяет сделать так, чтобы
 единовременно только один поток получал доступ к определенному ресурсу. Естественно,
 система может в любой момент вытеснить Ваш поток и подключить к процессору
 другой, но ни один из потоков, которым нужен занятый Вами ресурс, не получит
 процессорное время до тех пор, пока Ваш поток не выйдет за границы критической секции.

void WINAPI InitializeCriticalSection(
_Out_ LPCRITICAL_SECTION lpCriticalSection
);

Эта функция инициализирует элементы структуры CRITICAL_SECTION, на которую
указывает параметр lpCriticalSection. Поскольку вся работа данной функции заключается в инициализации
нескольких переменныххчленов, она не дает сбоев и поэтому ничего не
возвращает (void). InitializeCriticalSection должна быть вызвана до того, как один из
потоков обратится к EnterCriticalSection.


Если Вы знаете, что структура CRITICAL_SECTION больше не понадобится ни одному 
потоку, удалите ее, вызвав
void WINAPI DeleteCriticalSection(
_Inout_ LPCRITICAL_SECTION lpCriticalSection
);

Она сбрасывает все переменныеечлены внутри этой структуры. Естественно,
нельзя удалять критическую секцию в тот момент, когда ею все еще пользуется каа
коййлибо поток

Участок кода, работающий с разделяемым ресурсом, предваряется вызовом:
void WINAPI EnterCriticalSection(
_Inout_ LPCRITICAL_SECTION lpCriticalSection
);

Первое, что делает EnterCriticalSection, — исследует значения элементов структуры 
CRITICAL_SECTION. Если ресурс занят, в них содержатся сведения о том, какой
поток пользуется ресурсом. 

В конце участка кода, использующего разделяемый ресурс, должен присутствовать
вызов:
void WINAPI LeaveCriticalSection(
_Inout_ LPCRITICAL_SECTION lpCriticalSection
);

Эта функция просматривает элементы структуры CRITICAL_SECTION и уменьшаа
ет счетчик числа захватов ресурса вызывающим потоком на 1. Если его значение больше 0, 
LeaveCriticalSection ничего не делает и просто возвращает управление.
Если значение счетчика достигло 0, LeaveCriticalSection сначала выясняет, есть ли
в системе другие потоки, ждущие данный ресурс в вызове EnterCriticalSection. Если есть
хотя бы один такой поток, функция настраивает значения элементов структуры, чтобы 
они сигнализировали о занятости ресурса, и отдает его одному из ждущих потоков 
(поток выбирается «по справедливости»). Если же ресурс никому не нужен, LeaveCriticalSection
 соответственно сбрасывает элементы структуры.


BOOL WINAPI TryEnterCriticalSection(
_Inout_ LPCRITICAL_SECTION lpCriticalSection
);

Эта функция никогда не приостанавливает выполнение вызывающего потока. Но
возвращаемое ею значение сообщает, получил ли этот поток доступ к ресурсу. Если
при ее вызове указанный ресурс занят другим потоком, она возвращает FALSE.



--- Мьютексы ---

 • Windows API •

Объекты ядра «мьютексы» гарантируют потокам взаимоисключающий доступ к единн
ственному ресурсу. Они содержат счетчик числа пользователей, счетчик рекурсии и переменную,
в которой запоминается идентификатор потока. Мьютексы ведут себя точно так же,
как и критические секции. Однако, если последние являются объектами пользовательь
ского режима, то мьютексы — объектами ядра. Кроме того, единственный объекттмьюю
текс позволяет синхронизировать доступ к ресурсу нескольких потоков из разных
процессов; при этом можно задать максимальное время ожидания доступа к ресурсу.
Идентификатор потока определяет, какой поток захватил мьютекс, а счетчик рее
курсий — сколько раз. У мьютексов много применений, и это наиболее часто испольь
зуемые объекты ядра. Как правило, с их помощью защищают блок памяти, к котороо
му обращается множество потоков. Если бы потоки одновременно использовали каа
коййто блок памяти, данные в нем были бы повреждены. Мьютексы гарантируют, что
любой поток получает монопольный доступ к блоку памяти, и тем самым обеспечии
вают целостность данных.

Для мьютексов определены следующие правила:
• если его идентификатор потока равен 0 (у самого потока не может быть таа
кой идентификатор), мьютекс не захвачен ни одним из потоков и находится в
свободном состоянии;
• если его идентификатор потока не равен 0, мьютекс захвачен одним из потоо
ков и находится в занятом состоянии;


HANDLE WINAPI CreateMutex(
_In_opt_ LPSECURITY_ATTRIBUTES lpMutexAttributes,
_In_ BOOL bInitialOwner,
_In_opt_ LPCTSTR lpctszName
);

HANDLE OpenMutex(
DWORD fdwAccess,
BOOL bInheritHandle,
PCTSTR pszName);

Параметр bInitialOwner определяет начальное состояние мьютекса. Если в нем пее
редается FALSE (что обычно и бывает), объекттмьютекс не принадлежит ни одному
из потоков и поэтому находится в свободном состоянии. При этом его идентификаа
тор потока и счетчик рекурсии равны 0. Если же в нем передается TRUE, идентифии
катор потока, принадлежащий мьютексу, приравнивается идентификатору вызываюю
щего потока, а счетчик рекурсии получает значение 1. Поскольку теперь идентифии
катор потока отличен от 0, мьютекс изначально находится в занятом состоянии.
Поток получает доступ к разделяемому ресурсу, вызывая одну из Wait-функций и
передавая ей описатель мьютекса, который охраняет этот ресурс. Wait-функция проо
веряет у мьютекса идентификатор потока: если его значение не равно 0, мьютекс своо
боден; в ином случае оно принимает значение идентификатора вызывающего потоо
ка, и этот поток остается планируемым.
Если Wait-функция определяет, что у мьютекса идентификатор потока не равен 0
(мьютекс занят), вызывающий поток переходит в состояние ожидания. Система заа
поминает это и, когда идентификатор обнуляется, записывает в него идентификатор
ждущего потока, а счетчику рекурсии присваивает значение 1, после чего ждущий
поток вновь становится планируемым. Все проверки и изменения состояния объекк
таамьютекса выполняются на уровне атомарного доступа.


BOOL WINAPI ReleaseMutex(
_In_ HANDLE hMutex
);

Эта функция уменьшает счетчик рекурсии в объектеемьютексе на 1. Если данный
объект передавался во владение потоку неоднократно, поток обязан вызвать Releasee
Mutex столько раз, сколько необходимо для обнуления счетчика рекурсии. Как тольь
ко счетчик станет равен 0, переменная, хранящая идентификатор потока, тоже обнуу
лится, и объекттмьютекс освободится. После этого система проверит, ожидают ли
освобождения мьютекса какиеенибудь другие потоки. Если да, система «поочестному»
выберет один из ждущих потоков и передаст ему во владение объекттмьютекс.

HANDLE g_hMutex = INVALID_HANDLE_VALUE;

 • POSIX •

 Динамическая инициализация мьютекса выполняется так
int pthread_mutex_init(
pthread_mutex_t *restrict pMutex,
const pthread_mutexattr_t *restrict pAttr);

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

int pthread_mutex_destroy(
pthread_mutex_t * pMutex);

Захват мьютекса выполняется очень просто:
int pthread_mutex_lock(
pthread_mutex_t * pMutex);
Захватывает указанный мьютекс. Если блокировка недос-
тупна, процесс переводится в состояние ожидани

int pthread_mutex_trylock(
pthread_mutex_t * pMutex);
Пытается захватить указанный мьютекс. Если мьютекс ус-
пешно захвачен, возвращается значение 1, в противном
случае возвращается нуль


Освобождение мьютекса выполняется очень просто:
int pthread_mutex_unlock(
pthread_mutex_t * pMutex);
Освобождает указанный мьютекс

• Повторные захваты и освобождения мьютексов не разрешаются. Это означает,
что нельзя повторно захватить тот же самый мьютекс и нельзя освободить уже
освобожденный мьютекс.
• Процесс не может завершить свою работу до тех пор, пока  он  не  освободит
мьютекс.

pthread_mutex_t g_Mutex = PTHREAD_MUTEX_INITIALIZER;
	
-- Блокировка с двойной проверкой. --
Data *get_data()
{
	// ...
	if (!g_List.empty())
		{
			pthread_mutex_lock(&g_Mutex);
			if (!g_List.empty())
				{
					pData = g_List.back();
					g_List.pop_back();
				}
			pthread_mutex_unlock(&g_Mutex);
		}
}		


Барьер по памяти: (memory barrier, memory fence) - точка в коде программы,
для которой гарантируется, что все операции доступа к памяти,
выполненные до неё, завершатся до начала операций с памятью
после неё.


В случае, когда необходимо иметь дело с синхронизацией между разными процессорами или разными 
аппаратными устройствами, иногда возникает требование, чтобы чтение памяти (load) или запись в память 
(save) выполнялись в том же по­рядке, как это указано в исходном программном коде. При работе с аппаратными 
устройствами часто необходимо, чтобы некоторая указанная операция чтения была выполнена перед другими 
операциями чтения или записи. В дополнение к этому, насимметричной многопроцессорной системе может 
оказаться необходимым, чтобы операции записи выполнялись строго в том порядке, как это указано в исходном 
программном коде (обычно для того, чтобы гарантировать, что последовательные операции чтения получают данные 
в том же порядке). Эти проблемы усложняются тем, что как компилятор, так и процессор могут менять порядок 
операций чтения и записи6 для повышения производительности. К счастью, все процессоры, которые переопределяют 
порядок операций чтения или записи предоставляют машинные инструкции, которые требуют выполнения операций 
чтения-записи памяти в ука­занном порядке. Также существует возможность дать инструкцию компилятору, что нельзя 
изменять порядок выполнения операций при переходе через определенную точку программы. Эти инструкции называются 
барьерами (barrier). Рассмотрим следующий код.
а = 1; Ь = 2 ;
На некоторых процессорах запись нового значения в область памяти, занимае­мую переменной b, может выполниться 
до того, как будет записано новое значение в область памяти переменной а. Компилятор может выполнить такую 
перестановку статически и внести в файл объектного кода, что значение переменной b должно быть установлено перед 
переменной a. Процессор может изменить порядок выпол­нения динамически путем предварительной выборки и планирования
 выполнения внешне вроде бы независимых инструкций для повышения производительности. В большинстве случаев такая
 перестановка операций будет оптимальной, так как между переменными a и b нет никакой зависимости. Тем не менее 
 иногда програм­мисту все-таки виднее.
Хотя в предыдущем примере и может быть изменен порядок выполнения, ни процессор, ни компилятор никогда не будут 
менять порядок выполнения следующе­го кода, где переменные а и b являются глобальными.
а = 1; b = а;
Это происходит потому, что в последнем случае четко видно зависимость между переменными a и b. Однако ни компилятор,
 ни процессор не имеют никакой ин­формации о коде, который выполняется в других контекстах. Часто важно, 
 чтобы результаты записи в память "виделись" в нужном порядке другим кодом, который выполняется за пределами нашей 
 досягаемости. Такая ситуация часто имеет место при работе с аппаратными устройствами, а также возникает на многопроцессорных машинах.
 
 Пример (поток 0)							Пример (поток 1)
 
пока b =”ложь“, выполнять					x < 42;
; // пусто									// барьер
// барьер									b < ”истина“;		
Напечатать(x);


--- Семафор --- 

Объекты ядра «семафор» используются для учета ресурсов. Как и все объекты ядра,
они содержат счетчик числа пользователей, но, кроме того, поддерживают два 32
битных значения со знаком: одно определяет максимальное число ресурсов (контроо
лируемое семафором), другое используется как счетчик текущего числа ресурсов.

Для семафоров определены следующие правила:
• когда счетчик текущего числа ресурсов становится больше 0, семафор переходит
	в свободное состояние;
• если этот счетчик равен 0, семафор занят;
• система не допускает присвоения отрицательных значений счетчику текущего 
	числа ресурсов;
• счетчик текущего числа ресурсов не может быть больше максимального числа 
	ресурсов.

 
 • Windows API •

 Объект ядра «семафор» создается вызовом CreateSemaphore:
HANDLE WINAPI CreateSemaphore(
_In_opt_ LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
_In_ LONG lInitialCount,
_In_ LONG lMaximumCount,
_In_opt_ LPCTSTR lpctszName
);

Разумеется, любой процесс
может получить свой («процессоозависимый») описатель существующего объекта «семафор», вызвав OpenSemaphore:

HANDLE OpenSemaphore(
DWORD fdwAccess,
BOOL bInheritHandle,
PCTSTR pszName);

Параметр lMaximumCount сообщает системе максимальное число ресурсов, обраа
батываемое Вашим приложением. Поскольку это 32 битное значение со знаком, прее
дельное число ресурсов может достигать 2 147 483 647. Параметр lInitialCount указыы
вает, сколько из этих ресурсов доступно изначально (на данный момент). 

Поток увеличивает значение счетчика текущего числа ресурсов, вызывая функцию
ReleaseSemaphore:

BOOL WINAPI ReleaseSemaphore(
_In_ HANDLE hSemaphore,
_In_ LONG lReleaseCount,
_Out_opt_ LPLONG lplPreviousCount
);
Она просто складывает величину lReleaseCount со значением счетчика текущего
числа ресурсов. Обычно в параметре lReleaseCount передают 1, но это вовсе не обязаа
тельно: я часто передаю в нем значения, равные или большие 2. Функция возвращает
исходное значение счетчика ресурсов в *plPreviousCount. Если Вас не интересует это
значение (а в большинстве программ так оно и есть), передайте в параметре plPree
viousCount значение NULL.

Поток получает доступ к ресурсу, вызывая одну из Wait-функций и передавая ей
описатель семафора, который охраняет этот ресурс. Wait-функция проверяет у семафора
 счетчик текущего числа ресурсов: если его значение больше 0 (семафор свободен),
 уменьшает значение этого счетчика на 1, и вызывающий поток остается планируемым.
 Очень важно, что семафоры выполняют эту операцию проверки и присвоения на уровне 
 атомарного доступа; иначе говоря, когда Вы запрашиваете у семафора какой-либо ресурс,
 операционная система проверяет, доступен ли этот ресурс, и, если
да, уменьшает счетчик текущего числа ресурсов, не позволяя вмешиваться в эту операцию
 другому потоку. Только после того как счетчик ресурсов будет уменьшен на 1,
доступ к ресурсу сможет запросить другой поток.
Если Wait?функция определяет, что счетчик текущего числа ресурсов равен 0 (семафор занят),
 система переводит вызывающий поток в состояние ожидания. Когда
другой поток увеличит значение этого счетчика, система вспомнит о ждущем потоке
и снова начнет выделять ему процессорное время (а он, захватив ресурс, уменьшит
значение счетчика на 1

 • POSIX •
 
 В операционной системе Linux семафоры (semaphore) — это блокировки, которые пере-
водят процессы в состояние ожидания. При попытке захвата семафора, который уже за-
хвачен другой задачей, текущая задача помещается в очередь ожидания (wait queue) и за-
мораживается. После этого процессор переходит к выполнению другой задачи. Как
только требуемый семафор освобождается, одна из задач3, находящаяся в очереди ожи-
дания, активизируется, после чего она может захватить требуемый семафор.
 
 
 Объекты-семафоры представляются в виде структуры semaphore. Ста-
тическое  определение  семафоров  выполняется  так,  как  показано  ниже.  
Размещаемый в памяти семафор инициализируется вызовом sem_init. 
Аргумент pSem указывает на переменную типа sem_t, место под которую должно быть выделено
 приложением. Если аргумент bShared равен 0, семафор используется потоками одного процесса,
 в противном случае доступ к нему могут иметь несколько процессов. Если аргумент bShared
 ненулевой, семафор должен быть размещен в одном из видов разделяемой памяти и должен 
 быть доступен всем процессам, использующим его. Как и в вызове sem_open, аргумент 
 uValue задает начальное значение семафора.

int sem_init(
sem_t * pSem,
int bShared,
unsigned uValue);

После завершения работы с размещаемым в памяти семафором его можно уничтожить, вызвав sem_destroy.
int sem_destroy(
sem_t * pSem);

Функция sem_wait проверяет значение заданного семафора на положительность, уменьшает его на единицу 
и немедленно возвращает управление процессу. Если значение семафора при вызове функции равно нулю,
 процесс приостанавливается, до тех пор пока оно снова не станет больше нуля, после чего значение
 семафора будет уменьшено на единицу и произойдет возврат из функции. Ранее мы отметили, что операция 
 «проверка и уменьшение» должна быть атомарной по отношению к другим потокам, работающим с этим семафором:
int sem_wait(sem_t *pSem);

int sem_trywait(sem_t *pSem);
/* Обе функции возвращают 0 в случае успешного завершения. –1 – в случае ошибки */
Разница между sem_wait и sem_trywait заключается в том, что последняя не приостанавливает выполнение 
процесса, если значение семафора равно нулю, а просто немедленно возвращает ошибку EAGAIN.
Возврат из функции sem_wait может произойти преждевременно, если будет получен сигнал. При этом возвращается ошибка с кодом EINTR.

int sem_post(sem_t *pSem);
После завершения работы с семафором поток вызывает sem_post. Этот вызов увеличивает значение семафора на единицу 
и возобновляет выполнение любых потоков, ожидающих изменения значения семафора.
Функция возвращают 0 в случае успешного завершения. –1 – в случае ошибки.

----------- Организация кольцевого буфера чтения/записи ----------- 

Применение кольцевого буфера (ring buffer) - обычный прием, когда нужно организовать поток данных между асинхронными
 по отношению друг к другу процессами - например, между получением данных по каналу связи и обработкой этих данных в 
 программе. Кольцевой буфер является упрощенным аналогом очереди (queue), которая применяется в многозадачных операционных
 системах (Windows, Linux, FreeRTOS и многих других) для организации безопасного (thread-safe) обмена данных между потоками
 (синхронизации).

Кольцевой буфер может использоваться не только на прием, но и на передачу - например, если нужно быстро подготовленные 
где-то данные постепенно передавать с течением времени. Кольцевой буфер удобен прежде всего тем, что очень просто производить
 заполнение буфера, проверку наличия данных в буфере и выборку данных из буфера, при этом не нужно особенно беспокоиться о 
 выходе данных за границу буфера, переполнении памяти и т. п. Кольцевой буфер позволяет корректно обмениваться данными между 
 обработчиком прерывания и основной программой.

Кольцевой буфер является разновидностью буфера FIFO, First Input First Output (первый зашел - первый вышел). Принцип 
кольцевого буфера довольно прост - в памяти выделяется непрерывный блок размером обычно равным степени двойки (назовем его buffer),
 и два индекса (idxIN и idxOUT) - один индекс указывает на место для записи в буфер (idxIN), другой - на место чтения из буфера. 
 Размер буфера, равный степени двойки, выбирается для того, чтобы удобно было манипулировать индексами, указывающими на данные буфера, 
 с помощью инкремента/декремента и наложения маски (это будет понятно далее). Индекс - это обычное число, равное адресу ячейки буфера.
 Например, на ячейку buffer[0] указывает индекс, равный нулю. Количество бит индекса как раз равно степени двойки размера буфера. 
 Максимально удобны буфера размером 256 байт - в этом случае в качестве индекса можно применить 1 байт, и маску при операциях с 
 указателями уже накладывать не надо. Код получается в этом случае максимально быстрый и компактный. На рисунке 7 показан принцип 
 работы кольцевого буфера на примере буфера в 16 байт (желтым показаны еще не обработанные данные буфера).

 
 
 ------------- БАРЬЕРЫ ------------- 
 
 При обеспечении синхронной работы нескольких процессоров или аппаратных уст-
ройств иногда нужно, чтобы операции чтения (загрузки) и записи (сохранения) в память
выполнялись именно в том порядке, в каком это было указано в коде программы. При
работе с аппаратными устройствами часто необходимо, чтобы заданная операция чтения
была выполнена перед другими операциями чтения или записи. Кроме того, на симмет-
ричной многопроцессорной системе иногда требуется, чтобы операции записи выполня-
лись строго в том порядке, в каком они были указаны в исходном программном коде.
Как правило, это нужно для того, чтобы последующие операции чтения могли извлечь
данные в том же порядке, в котором они были записаны. Описанные выше проблемы ус-
ложняются еще и тем, что и компилятор, и процессор могут изменять порядок выполне-
ния команд чтения и записи6 для повышения производительности работы программы.
К счастью, в тех процессорах, в которых может изменяться порядок выполнения команд
чтения и записи, предусмотрены специальные машинные команды, позволяющие строго
определить этот порядок. Также существует возможность указать компилятору, что не
следует  изменять  порядок  выполнения  операций  вокруг  некоторой  точки  программы.
Эти указания называются барьерами (barriers).


Барьер — один из примитивов синхронизации. Он создаётся на некоторое количество потоков. 
Когда первый поток завершает свою работу, то он остаётся ждать у барьера и ждёт, пока не 
завершат работу остальные потоки.
Как только у барьера накапливается ровно столько потоков, на сколько был создан барьер, 
все потоки, которые ожидают у барьера, продолжают свою работу. 

 • Windows API •

 BOOL WINAPI InitializeSynchronizationBarrier(
_Out_ LPSYNCHRONIZATION_BARRIER lpBarrier,
_In_ LONG lTotalThreads,
_In_ LONG lSpinCount
);

Параметры:
lpBarrier - указатель на барьер
lTotalThreads - максимальное кол-во потоков, которые могут входить в барьер
lSpinCount - Количество раз, которое индивидуальный поток должен вращаться 
			 во время ожидания других потоков, чтобы прийти к барьеру.
			 Если этот параметр равен -1, то поток крутится в 2000 раз. Если поток 
			 превышает lSpinCount, поток блокируется, если он не называется 
			 EnterSynchronizationBarrier с SYNCHRONIZATION_BARRIER_FLAGS_SPIN_ONLY.
Возвращаемое значение: 
TRUE, если барьер был удачно инициализирован. Иначе - функция возвращает FALSE. 
Для получения подробной информации об ошибке следует воспользоваться ф-ей GetLastError.

BOOL WINAPI DeleteSynchronizationBarrier(
_Inout_ LPSYNCHRONIZATION_BARRIER lpBarrier
);

lpBarrier - указатель на барьер
Возвращаемое значение: 
Ф-ия DeleteSynchronizationBarrier всегда возвращает TRUE.

Является причиной "призыва" потока ожидать барьер до тех пор, пока максимальное число потоков не вступят в барьер
BOOL WINAPI EnterSynchronizationBarrier(
_Inout_ LPSYNCHRONIZATION_BARRIER lpBarrier,
_In_ DWORD dwFlags
);

lpBarrier  - указатель на барьер
dwFlags - флаги для того, чтобы контролировать поведение потоков, которые вошли в барьер. Этот параметр может быть одиночным
		  или множественным (зависит от значений флагов).

		  
 • POSIX •		  

Инициализация барьера:
int pthread_barrier_init(
pthread_barrier_t *restrict pBarrier,
const pthread_barrierattr_t *restrict pAttr,
unsigned uCount);

pBarrier - указатель на барьер
pAttr - аттрибуты барьера
uCount - максимальное кол-во потоков, которые могут входить в барьер

Удаление барьера: 
int pthread_barrier_destroy(
pthread_barrier_t * pBarrier);

Ожидание барьера:
int pthread_barrier_wait(
pthread_barrier_t * pBarrier);

If successful, both pthread_barrier_destroy ();
and pthread_barrier_init ();
will return zero. Otherwise, an error number will be returned to indicate the error. 
If the call to pthread_barrier_wait ();
is successful, all but one of the threads will return zero. That one thread will return 
PTHREAD_BARRIER_SERIAL_THREAD Otherwise, an error number will be returned to indicate the error.